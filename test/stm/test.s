/*
https://blog.csdn.net/u011449588/article/details/44945411

1.LDMIA指令、LDMIB指令、LDMDB指令、LDMDA指令

（1）LDMIA指令，IA表示每次传送后地址加4
（2）LDMIB指令，每次传送前地址加四
（3）LDMDB指令，每次传送前地址减4，这里还要注意程序中先给R5，还是先给R8，这里明显是先给R8
（4）LDMDA指令，每次传送后地址减4，这里也是先给R8，不是先给R5！！

STMIA指令、STMIB指令、STMDB指令、STMDA指令
（1）      STMIA指令, STMIA R0,{R1,R2,R3,R4}  ;
            将R1—R4的数据存储到R0指向的地址上，R0的值不更新，IA传送后地址加4，所以这里内存当中的地址是从0x8004开始变化的
（2）      STMIB指令, STMIB R0,{R1,R2,R3,R4}  ;将R1—R4的数据存储到R0指向的地址上，
            R0的值不更新，IB每次传送前地址加4，所以内存中的值是从0x8008开始变化的
（3）      STMDB指令, STMDB R0,{R1,R2,R3,R4}  ;将R1—R4的数据存储到R0指向的地址上，R0的值不更新，DB每次传送后地址减4，所以内存中的值是从0x8010开始递减变化的，注意这里是先把表达式中的R4先给地址0x8010
（4）      STMDA与上面STMDB指令类似，DA是每次传送后地址减4，

堆栈寻址方式，依次讲解STMFD、STMED、STMFA、STMEA
1.      STM加载指令

（1）      STMFD意思是满堆栈递减指令，堆栈向下增长。如下图就是解释堆栈向下增长，向下增长，
栈顶指针在内存中向低地址处移动，叫做向下增长,这里我为什么要先讲STMFD指令，怎么不讲LDMFD等指令呢，
因为这里涉及到堆栈，向内存中写入寄存器中所存储的值，更能体现出进栈的动作，看完下面的例子，
你会知道STM的后缀为什么是FD了。
关键代码：STMFDSP!,{R1-R3,R4}，可以这么看，先把R4，R3，R2，R1依次压栈，至于为什么不是R1，R2，R3，R4
依次压栈，因为做出的实验就不是这样的，所以R4准备进栈的时候，栈指针SP先减4，然后先把R4寄存器里面的值放到
内存地址为0x803c里面，这里为什么SP要先减4呢，因为这里是满堆栈，所以要先把栈指针做出响应的变化以后，才能
进行存储，至于什么是满堆栈和空堆栈，我这里就不解释了。

https://blog.csdn.net/wangkaiming123456/article/details/80054037
ARM指令中多数据传输共有两种:

LDM:(load  much)多数据加载,将地址上的值加载到寄存器上

STM:(store much)多数据存储,将寄存器的值存到地址上

主要用途：现场保护、数据复制、参数传送等，共有8种模式（前面4种用于数据块的传输，后面4种是堆栈操作）如下：

（1）IA:（Increase After） 每次传送后地址加4,其中的寄存器从左到右执行,例如:STMIA R0,{R1,LR} 先存R1,再存LR

（2）IB:（Increase Before）每次传送前地址加4,同上

（3）DA:（Decrease After）每次传送后地址减4,其中的寄存器从右到左执行,例如:STMDA R0,{R1,LR} 先存LR,再存R1

（4）DB：（Decrease Before）每次传送前地址减4,同上

（5）FD:  满递减堆栈 (每次传送前地址减4)

（6）FA:  满递增堆栈 (每次传送后地址减4)

（7）ED:  空递减堆栈 (每次传送前地址加4)

（8）EA:  空递增堆栈 (每次传送后地址加4)

注意：其中在数据块的传输中是STMMDB和LDMIA对应，STMMIA和LDMDB对应

而在堆栈操作是STMFD和LDMFD对应，STMFA和LDMFA对应

格式:

LDM{cond}  mode  Rn{!}, reglist{^}

STM{cond}  mode  Rn{!}, reglist{^}

其中

 Rn：基址寄存器，装有传送数据的起始地址，Rn不允许为R15；

 ！：表示最后的地址写回到Rn中；

 reglist：可包含多于一个寄存器范围，用“，”隔开，如{R1，R2，R6-R9}，寄存器由小到大顺序排列；

 ^：不允许在用户模式和系统模式下运行

 
数据块的传输-实例:

Ldr R1,=0x10000000          //传送数据的起始地址0x10000000     

LDMIB R1!,{R0,R4-R6}      //从左到右加载,相当于 LDR R0,10000004  LDR R4,10000008... ...

传送前地址加+4,
所以地址加4,R0=0X1000004地址里的内容，
地址加4,R4=0X10000008地址里的内容，
地址加4,R5=0X1000000C地址里的内容，
地址加4,R6=0X10000010 地址里的内容，
由于!, 最后的地址写回到R1中,R1=0X10000010   

 

Ldr R1,=0x10000000          //传送数据的起始地址0x10000000        


LDMIA R1!,{R0,R4-R6}         //从左到右加载,相当于 LDR R0,10000000  LDR R4,10000004... ...

传送后地址加+4,
所以R0=0X10000000地址里的内容，地址加4,
R4=0X10000004地址里的内容，地址加4,
R5=0X10000008地址里的内容，地址加4,
R6=0X1000000C 地址里的内容，地址加4,
由于!,最后的地址写回到R1中,所以R1=0X10000010   
LDR R1,=0x10000000          //传送数据的起始地址0x10000000        

 

LDR R4,=0X10
LDR R5,=0X20
LDR R6,=0X30
STMIB R1,{R4-R6}          //从左到右加载,相当于STR [R4],0X10000004    STR [R5],0X10000008 .....
//传送前地址加+4,所以0X10000004地址=0X10，0X10000008地址=0X20，0X1000000C地址=0X30 

 
Ldr R1,=0x10000000        //传送数据的起始地址0x10000000  
LDR R4,=0X10
LDR R5,=0X20
LDR R6,=0X30           
STMIA R1!,{R4-R6 }     
//传送后地址加+4,所以0X10000000地址=0X10，0X10000004地址=0X20，0X10000008地址=0X30，由于!,最后的地址写回到R1中,所以R1=0X1000000C  

中断实例(利用STMDB和LDMIA保护现场,然后通过LR寄存器返回) 

1.先设置栈sp,用于后面使用stmdb存储寄存器数据

2.当产生异常时，便进入中断:

sub lr, lr, #4                  

 //首先将lr-4,因为arm流水线,lr=当前pc+8,由于pc+4段没有执行，所以lr=(当前pc+8)-4;
stmdb sp!, { r0-r12,lr }  

//每次传送前-4,由于递减,所以从右往左存储寄存器

//所以sp-4=lr,sp-8=r12,... sp-56=r0; 由于!，所以最后的地址写回到sp中,sp=sp-56;
 

ldr lr, =int_return  //设置返回地址

ldr pc, =EINT_Handle //进入中断服务函数,如果中途返回就会调用pc=lr,即可执行int_return;

int_return:
ldmia sp!, { r0-r12,pc }^  

//每次传送后+4,所以从左往右加载数据到寄存器

//所以r0=sp, r1=sp+4,...pc=sp+52;由于!，所以最后地址写回到sp中,sp=sp+56;

//此时,sp=sp+56就等于最初栈顶值,pc=lr,然后返回到异常发生前的相应位置继续执行。

//^  ^表示将spsr的值复制到cpsr,因为异常返回后需要恢复异常发生前的工作状态


@ */



.word stack_top
.word _start

.global _start


_start:
ldr r0, =str
bl uart_printf






b .

.set UART_DR,0x4000c000
uart_printf:
    push    {lr}
    movw    r1, #0xc000 /*加载地址到r1低16位*/
    movt    r1, #0x4000 /*加载地址到r1高16位*/
send_loop:
    ldrb     r2, [r0]   /*从R0地址处加载一个byte到r2,r0为字符串所在地址*/
    cbz r2, exit        /*如果 r2 为0,则 跳转到exit*/
    strb r2,[r1]        /*将r2的值写入r1地址*/
    add r0,r0,#1        /*r0加1*/
    b send_loop
exit:
    pop     {pc}

.section .rodata
str:
    .ascii "asm hello word\n"



