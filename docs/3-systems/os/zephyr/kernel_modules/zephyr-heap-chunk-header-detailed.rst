.. _zephyr-heap-chunk-header-detailed:

Zephyr 堆内存块头部详解
################################

.. contents::
    :local:
    :depth: 3

1. 核心概念：每个块都有头部
==============================

1.1 基本事实
------------

**重要事实**：每个内存块都有头部开销，用户**不能**使用全部的内存。

**示例**：
- 如果一个桶中有32字节的内存块
- 用户实际可用的内存可能只有24-28字节
- 剩余的4-8字节是块头部

1.2 为什么需要头部？
------------------

**头部的作用**：

1. **记录块大小**：知道这个块有多大
2. **记录使用状态**：知道这个块是已使用还是空闲
3. **维护邻居关系**：知道左右邻居是谁
4. **支持合并**：释放时能够与邻居合并

**没有头部的后果**：

- 无法知道块的大小
- 无法知道块是否被使用
- 无法正确释放内存
- 无法检测内存损坏

1.3 头部在哪里？
----------------

**已使用块**：

```
+------------------+------------------+
| 块头部 (4/8字节) | 用户数据区        |
+------------------+------------------+
 ↑                  ↑
 块的起始地址       返回给用户的地址
```

**空闲块**：

```
+------------------+------------------+------------------+
| 块头部 (4/8字节) | 空闲链表指针      | (用户数据区，未使用) |
+------------------+------------------+------------------+
 ↑                  ↑
 块的起始地址       空闲链表指针
```

**关键点**：

- 头部在块的**开始位置**
- 用户得到的是头部**之后**的地址
- 空闲块的头部之后是链表指针，不是用户数据

2. 三种配置下的头部结构
========================

2.1 小堆模式 (CONFIG_SYS_HEAP_SMALL_ONLY)
--------------------------------------

2.1.1 基本参数
~~~~~~~~~~~~~~

```
最大堆大小：262136 字节
块ID类型：uint16_t (16位)
块大小类型：uint16_t (16位)
头部大小：4 字节
单位大小：8 字节 (CHUNK_UNIT)
最大块数：32767 (0x7FFF)
```

2.1.2 头部结构详解
~~~~~~~~~~~~~~~

**已使用块的头部**（4字节）：

```
+--------+--------+--------+--------+
| 字节0   | 字节1   | 字节2   | 字节3   |
+--------+--------+--------+--------+
| LEFT_SIZE (16位) | SIZE_AND_USED (16位) |
+------------------+------------------+
```

**字段说明**：

- **LEFT_SIZE (16位)**：左侧相邻块的大小（单位数）
- **SIZE_AND_USED (16位)**：
  - 高15位：当前块的大小（单位数）
  - 最低1位：使用标志（0=空闲，1=已使用）

**示例**：

```
假设一个块：
- 大小：5个单位 = 40字节
- 左侧邻居：3个单位 = 24字节
- 状态：已使用

头部内容（4字节）：
+--------+--------+--------+--------+
| 0x03   | 0x00   | 0x0A   | 0x01   |
+--------+--------+--------+--------+
| LEFT_SIZE = 3      | SIZE = 5, USED = 1 |
+---------------------+-------------------+
```

**空闲块的头部**（4字节 + 4字节链表指针）：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节0   | 字节1   | 字节2   | 字节3   | 字节4   | 字节5   | 字节6   | 字节7   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| LEFT_SIZE (16位) | SIZE_AND_USED (16位) | FREE_PREV (16位) | FREE_NEXT (16位) |
+------------------+------------------+------------------+------------------+
```

**字段说明**：

- **LEFT_SIZE (16位)**：左侧相邻块的大小（单位数）
- **SIZE_AND_USED (16位)**：
  - 高15位：当前块的大小（单位数）
  - 最低1位：使用标志（0=空闲，1=已使用）
- **FREE_PREV (16位)**：空闲链表中的前一个块ID
- **FREE_NEXT (16位)**：空闲链表中的下一个块ID

**示例**：

```
假设一个空闲块：
- 大小：8个单位 = 64字节
- 左侧邻居：5个单位 = 40字节
- 空闲链表：块A <-> 当前块 <-> 块B

头部内容（8字节）：
+--------+--------+--------+--------+--------+--------+--------+--------+
| 0x05   | 0x00   | 0x10   | 0x00   | 0x??   | 0x??   | 0x??   | 0x??   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| LEFT_SIZE = 5      | SIZE = 8, USED = 0 | FREE_PREV = 块A | FREE_NEXT = 块B |
+---------------------+-------------------+------------------+------------------+
```

2.1.3 实际可用内存计算
~~~~~~~~~~~~~~~~~~~~~~

**公式**：

```
用户可用内存 = 块大小(字节) - 头部大小

其中：
块大小(字节) = 块大小(单位) × 8
头部大小 = 4 字节 (已使用)
         = 8 字节 (空闲，包含链表指针)
```

**具体例子**：

```
例子1：32字节的块（已使用）
块大小(单位) = 32 / 8 = 4
块大小(字节) = 4 × 8 = 32
头部大小 = 4 字节
用户可用 = 32 - 4 = 28 字节

内存布局：
+--------+----------------------------+
| 4字节  | 28字节                    |
| 头部   | 用户数据                  |
+--------+----------------------------+
```

```
例子2：64字节的块（已使用）
块大小(单位) = 64 / 8 = 8
块大小(字节) = 8 × 8 = 64
头部大小 = 4 字节
用户可用 = 64 - 4 = 60 字节

内存布局：
+--------+------------------------------------------------+
| 4字节  | 60字节                                        |
| 头部   | 用户数据                                      |
+--------+------------------------------------------------+
```

```
例子3：128字节的块（已使用）
块大小(单位) = 128 / 8 = 16
块大小(字节) = 16 × 8 = 128
头部大小 = 4 字节
用户可用 = 128 - 4 = 124 字节

内存布局：
+--------+----------------------------------------------------------------+
| 4字节  | 124字节                                                      |
| 头部   | 用户数据                                                    |
+--------+----------------------------------------------------------------+
```

**头部开销百分比**：

```
块大小(字节) | 头部(字节) | 用户可用 | 开销百分比
------------|------------|---------|----------
32          | 4          | 28      | 12.5%
64          | 4          | 60      | 6.25%
128         | 4          | 124     | 3.125%
256         | 4          | 252     | 1.56%
512         | 4          | 508     | 0.78%
1024        | 4          | 1020    | 0.39%
```

**观察**：块越大，头部开销的百分比越小。

2.2 大堆模式 (CONFIG_SYS_HEAP_BIG_ONLY)
----------------------------------

2.2.1 基本参数
~~~~~~~~~~~~~~

```
最大堆大小：16383 MB
块ID类型：uint32_t (32位)
块大小类型：uint32_t (32位)
头部大小：8 字节
单位大小：8 字节 (CHUNK_UNIT)
最大块数：2147483647 (0x7FFFFFFF)
```

2.2.2 头部结构详解
~~~~~~~~~~~~~~~

**已使用块的头部**（8字节）：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节0   | 字节1   | 字节2   | 字节3   | 字节4   | 字节5   | 字节6   | 字节7 |
+---------+--------+--------+--------+---------+--------+--------+------+
| LEFT_SIZE (32位)                    | SIZE_AND_USED (32位)             |
+-------------------------------------+---------------------------------+
```

**字段说明**：

- **LEFT_SIZE (32位)**：左侧相邻块的大小（单位数）
- **SIZE_AND_USED (32位)**：
  - 高31位：当前块的大小（单位数）
  - 最低1位：使用标志（0=空闲，1=已使用）

**示例**：

```
假设一个块：
- 大小：5个单位 = 40字节
- 左侧邻居：3个单位 = 24字节
- 状态：已使用

头部内容（8字节）：
+--------+--------+--------+--------+--------+--------+--------+--------+
| 0x03   | 0x00   | 0x00   | 0x00   | 0x0A   | 0x00   | 0x00   | 0x01   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| LEFT_SIZE = 3              | SIZE = 5, USED = 1              |
+---------------------------+---------------------------------+
```

**空闲块的头部**（8字节 + 8字节链表指针）：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节0   | 字节1   | 字节2   | 字节3   | 字节4   | 字节5   | 字节6   | 字节7   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| LEFT_SIZE (32位) | SIZE_AND_USED (32位) | FREE_PREV (32位) | FREE_NEXT (32位) |
+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节8   | 字节9   | 字节10  | 字节11  | 字节12  | 字节13  | 字节14  | 字节15  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

**字段说明**：

- **LEFT_SIZE (32位)**：左侧相邻块的大小（单位数）
- **SIZE_AND_USED (32位)**：
  - 高31位：当前块的大小（单位数）
  - 最低1位：使用标志（0=空闲，1=已使用）
- **FREE_PREV (32位)**：空闲链表中的前一个块ID
- **FREE_NEXT (32位)**：空闲链表中的下一个块ID

**示例**：

```
假设一个空闲块：
- 大小：8个单位 = 64字节
- 左侧邻居：5个单位 = 40字节
- 空闲链表：块A <-> 当前块 <-> 块B

头部内容（16字节）：
+--------+--------+--------+--------+--------+--------+--------+--------+
| 0x05   | 0x00   | 0x00   | 0x00   | 0x10   | 0x00   | 0x00   | 0x00   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| LEFT_SIZE = 5              | SIZE = 8, USED = 0              |
+---------------------------+---------------------------------+
| 0x??   | 0x??   | 0x??   | 0x??   | 0x??   | 0x??   | 0x??   | 0x??   |
+--------+--------+--------+--------+--------+--------+--------+--------+
| FREE_PREV = 块A           | FREE_NEXT = 块B                |
+---------------------------+---------------------------------+
```

2.2.3 实际可用内存计算
~~~~~~~~~~~~~~~~~~~~~~

**公式**：

```
用户可用内存 = 块大小(字节) - 头部大小

其中：
块大小(字节) = 块大小(单位) × 8
头部大小 = 8 字节 (已使用)
         = 16 字节 (空闲，包含链表指针)
```

**具体例子**：

```
例子1：32字节的块（已使用）
块大小(单位) = 32 / 8 = 4
块大小(字节) = 4 × 8 = 32
头部大小 = 8 字节
用户可用 = 32 - 8 = 24 字节

内存布局：
+--------+------------------------+
| 8字节  | 24字节                  |
| 头部   | 用户数据                |
+--------+------------------------+
```

```
例子2：64字节的块（已使用）
块大小(单位) = 64 / 8 = 8
块大小(字节) = 8 × 8 = 64
头部大小 = 8 字节
用户可用 = 64 - 8 = 56 字节

内存布局：
+--------+------------------------------------------------+
| 8字节  | 56字节                                        |
| 头部   | 用户数据                                      |
+--------+------------------------------------------------+
```

```
例子3：128字节的块（已使用）
块大小(单位) = 128 / 8 = 16
块大小(字节) = 16 × 8 = 128
头部大小 = 8 字节
用户可用 = 128 - 8 = 120 字节

内存布局：
+--------+----------------------------------------------------------------+
| 8字节  | 120字节                                                      |
| 头部   | 用户数据                                                    |
+--------+----------------------------------------------------------------+
```

**头部开销百分比**：

```
块大小(字节) | 头部(字节) | 用户可用 | 开销百分比
------------|------------|---------|----------
32          | 8          | 24      | 25%
64          | 8          | 56      | 12.5%
128         | 8          | 120     | 6.25%
256         | 8          | 248     | 3.125%
512         | 8          | 504     | 1.56%
1024        | 8          | 1016    | 0.78%
```

**观察**：相比小堆模式，大堆模式的头部开销更大，但支持更大的堆。

2.3 自适应模式 (CONFIG_SYS_HEAP_AUTO)
----------------------------------

2.3.1 基本参数
~~~~~~~~~~~~~~

```
最大堆大小：根据堆大小自动选择
块ID类型：uint16_t 或 uint32_t (根据堆大小)
块大小类型：uint16_t 或 uint32_t (根据堆大小)
头部大小：4 字节 (小堆) 或 8 字节 (大堆)
单位大小：8 字节 (CHUNK_UNIT)
最大块数：32767 (小堆) 或 2147483647 (大堆)
```

2.3.2 自动选择逻辑
~~~~~~~~~~~~~~~~~

**选择条件**（[heap.h:80-99](file:///f:\workspace\src\zephyr-src\zephyrprj-3.7.0\zephyr\lib\heap\heap.h#L80-L99)）：

.. code-block:: c

    static inline bool big_heap_chunks(chunksz_t chunks)
    {
        if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
            return false;
        }
        if (IS_ENABLED(CONFIG_SYS_HEAP_BIG_ONLY) || sizeof(void *) > 4U) {
            return true;
        }
        return chunks > 0x7fffU;  // 32767 个单位 = 262136 字节
    }

**判断逻辑**：

```
1. 如果配置为小堆模式 → 使用小堆头部 (4字节)
2. 如果配置为大堆模式 → 使用大堆头部 (8字节)
3. 如果是64位系统 → 使用大堆头部 (8字节)
4. 如果是32位系统且配置为自适应：
   - 堆大小 ≤ 262136 字节 → 使用小堆头部 (4字节)
   - 堆大小 > 262136 字节 → 使用大堆头部 (8字节)
```

2.3.3 实际可用内存计算
~~~~~~~~~~~~~~~~~~~~~~

**小堆情况**（堆 ≤ 262136 字节）：

```
公式：
用户可用内存 = 块大小(字节) - 4 字节

例子：32字节的块（已使用）
块大小(单位) = 32 / 8 = 4
块大小(字节) = 4 × 8 = 32
头部大小 = 4 字节
用户可用 = 32 - 4 = 28 字节
```

**大堆情况**（堆 > 262136 字节）：

```
公式：
用户可用内存 = 块大小(字节) - 8 字节

例子：32字节的块（已使用）
块大小(单位) = 32 / 8 = 4
块大小(字节) = 4 × 8 = 32
头部大小 = 8 字节
用户可用 = 32 - 8 = 24 字节
```

**头部开销对比**：

```
块大小(字节) | 小堆头部 | 大堆头部 | 小堆可用 | 大堆可用 | 小堆开销 | 大堆开销
------------|---------|---------|---------|---------|---------|---------
32          | 4       | 8       | 28      | 24      | 12.5%   | 25%
64          | 4       | 8       | 60      | 56      | 6.25%   | 12.5%
128         | 4       | 8       | 124     | 120     | 3.125%  | 6.25%
256         | 4       | 8       | 252     | 248     | 1.56%   | 3.125%
512         | 4       | 8       | 508     | 504     | 0.78%   | 1.56%
```

3. 头部字段详解
================

3.1 LEFT_SIZE 字段
------------------

**作用**：记录左侧相邻块的大小

**为什么需要**：

1. **双向遍历**：可以从任意块向左遍历
2. **合并检查**：释放时检查左侧邻居是否空闲
3. **边界检测**：检测缓冲区溢出

**使用示例**：

.. code-block:: c

    // 获取左侧邻居
    static inline chunkid_t left_chunk(struct z_heap *h, chunkid_t c)
    {
        return c - chunk_field(h, c, LEFT_SIZE);
    }

    // 检查缓冲区溢出
    __ASSERT(left_chunk(h, right_chunk(h, c)) == c,
             "corrupted heap bounds (buffer overflow?)");
```

3.2 SIZE_AND_USED 字段
-----------------------

**作用**：记录当前块的大小和使用状态

**位布局**：

```
小堆模式（16位）：
+---------------+---+
| 大小 (15位)   | U |
+---------------+---+
第15位         第0位

大堆模式（32位）：
+-------------------------------+---+
| 大小 (31位)                     | U |
+-------------------------------+---+
第31位                           第0位

其中 U = 使用标志 (0=空闲, 1=已使用)
```

**使用示例**：

.. code-block:: c

    // 获取块大小
    static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
    {
        return chunk_field(h, c, SIZE_AND_USED) >> 1;
    }

    // 获取使用状态
    static inline bool chunk_used(struct z_heap *h, chunkid_t c)
    {
        return chunk_field(h, c, SIZE_AND_USED) & 1U;
    }

    // 设置使用状态
    static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
    {
        if (used) {
            ((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
        } else {
            ((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
        }
    }
```

3.3 FREE_PREV 和 FREE_NEXT 字段
-------------------------------

**作用**：维护空闲块的循环链表

**为什么只在空闲块中存在**：

- 已使用块不需要链表指针
- 空闲块需要快速查找和操作
- 节省内存：已使用块的这部分空间可以给用户使用

**使用示例**：

.. code-block:: c

    // 获取前一个空闲块
    static inline chunkid_t prev_free_chunk(struct z_heap *h, chunkid_t c)
    {
        return chunk_field(h, c, FREE_PREV);
    }

    // 获取下一个空闲块
    static inline chunkid_t next_free_chunk(struct z_heap *h, chunkid_t c)
    {
        return chunk_field(h, c, FREE_NEXT);
    }

    // 设置前一个空闲块
    static inline void set_prev_free_chunk(struct z_heap *h, chunkid_t c,
                                           chunkid_t prev)
    {
        chunk_set(h, c, FREE_PREV, prev);
    }

    // 设置下一个空闲块
    static inline void set_next_free_chunk(struct z_heap *h, chunkid_t c,
                                           chunkid_t next)
    {
        chunk_set(h, c, FREE_NEXT, next);
    }
```

4. 实际应用示例
================

4.1 分配32字节内存
------------------

**场景**：用户请求分配32字节

**小堆模式**：

```
步骤1：计算需要的块大小
bytes_to_chunksz(h, 32) = chunksz(4 + 32)  // 4是小堆头部大小
                            = chunksz(36)  // 总字节数（头部+用户数据）
                            = (36 + 8 - 1) / 8  // CHUNK_UNIT=8，向上取整计算块数
                            = 43 / 8 = 5.375 → 向上取整为5块

步骤2：假设错误地只分配1块
实际分配的块大小 = 1个单位 = 8字节

步骤3：从桶中分配
假设从桶0分配了一个2个单位的块

步骤4：块分割
原始块：2个单位 = 16字节
需要：1个单位 = 8字节
分割后：
  - 块1：1个单位 = 8字节（分配给用户）
  - 块2：1个单位 = 8字节（返回到桶0）

步骤5：返回给用户
用户得到：8 - 4 = 4字节

问题：用户请求32字节，只得到4字节！

原因：块太小，需要更大的块
```

**正确的分配**：

```
步骤1：计算需要的块大小
bytes_to_chunksz(h, 32) = chunksz(4 + 32)  // 4是小堆头部大小
                            = chunksz(36)  // 总字节数（头部+用户数据）
                            = (36 + 8 - 1) / 8  // CHUNK_UNIT=8，向上取整计算块数
                            = 43 / 8 = 5.375 → 向上取整为5块

步骤2：计算实际分配的内存
块大小：5块 × 8字节/块 = 40字节
头部：4字节
用户可用：40 - 4 = 36字节

满足用户32字节的需求
```

**大堆模式**：

```
步骤1：计算需要的块大小
bytes_to_chunksz(h, 32) = chunksz(8 + 32)  // 8是大堆头部大小
                            = chunksz(40)  // 总字节数（头部+用户数据）
                            = (40 + 8 - 1) / 8  // CHUNK_UNIT=8，向上取整计算块数
                            = 47 / 8 = 5.875 → 向上取整为5块

步骤2：计算实际分配的内存
块大小：5块 × 8字节/块 = 40字节
头部：8字节
用户可用：40 - 8 = 32字节

刚好满足用户32字节的需求
```

4.2 获取实际可用大小
----------------------

**使用 sys_heap_usable_size()**：

.. code-block:: c

    void *ptr = sys_heap_alloc(&heap, 32);
    if (ptr) {
        size_t usable = sys_heap_usable_size(&heap, ptr);
        printk("Requested: 32 bytes, Usable: %zu bytes\n", usable);
    }

**小堆模式输出**：

```
Requested: 32 bytes, Usable: 36 bytes
```

**大堆模式输出**：

```
Requested: 32 bytes, Usable: 32 bytes
```

**注意**：实际可用大小可能大于请求大小，这是正常的。

4.3 缓冲区溢出检测
--------------------

**原理**：检查左右邻居的一致性

.. code-block:: c

    // [heap.c:183-185]
    __ASSERT(left_chunk(h, right_chunk(h, c)) == c,
             "corrupted heap bounds (buffer overflow?) for memory at %p",
             mem);

**工作原理**：

```
正常情况：
+--------+--------+--------+
| 块A    | 块B    | 块C    |
+--------+--------+--------+
         ↑
      当前块

检查：
left_chunk(right_chunk(块B)) == left_chunk(块C) == 块B ✓

溢出情况（用户写入超过块B的边界）：
+--------+--------+--------+
| 块A    | 块B    | 块C    |
+--------+--------+--------+
         ↑
      当前块
         ↓
    破坏了块C的头部

检查：
left_chunk(right_chunk(块B)) == left_chunk(块C) != 块B ✗
检测到溢出！
```

5. 性能影响分析
================

5.1 头部开销对比
----------------

**小堆 vs 大堆**：

```
场景：分配1000个32字节的块

小堆模式：
- 每个块：32字节总大小，4字节头部，28字节用户数据
- 总堆大小：1000 × 32 = 32000字节
- 用户可用：1000 × 28 = 28000字节
- 头部开销：1000 × 4 = 4000字节 (12.5%)

大堆模式：
- 每个块：32字节总大小，8字节头部，24字节用户数据
- 总堆大小：1000 × 32 = 32000字节
- 用户可用：1000 × 24 = 24000字节
- 头部开销：1000 × 8 = 8000字节 (25%)

结论：小堆模式节省了4000字节
```

5.2 内存效率优化
----------------

**策略1：增大块大小**

```
场景：分配1000个256字节的块

小堆模式：
- 每个块：256字节总大小，4字节头部，252字节用户数据
- 头部开销：1.56%

大堆模式：
- 每个块：256字节总大小，8字节头部，248字节用户数据
- 头部开销：3.125%

结论：块越大，头部开销的百分比越小
```

**策略2：使用内存池**

```
场景：频繁分配固定大小的对象

使用堆：
- 每次分配都有头部开销
- 需要频繁的分配/释放

使用内存池：
- 预分配一块大内存
- 每个小对象没有头部开销
- 分配/释放只是简单的指针操作

结论：对于固定大小的对象，内存池更高效
```

6. 最佳实践
============

6.1 选择合适的堆模式
--------------------

**小堆模式适用场景**：

- 堆大小 ≤ 262136 字节
- 大量小分配（<256字节）
- 内存资源紧张

**大堆模式适用场景**：

- 堆大小 > 262136 字节
- 需要大块分配
- 64位系统

**自适应模式适用场景**：

- 不确定堆大小
- 需要最优内存效率
- 可以接受稍高的代码大小

6.2 优化内存使用
----------------

**技巧1：了解实际可用大小**

.. code-block:: c

    void *ptr = sys_heap_alloc(&heap, requested_size);
    if (ptr) {
        size_t usable = sys_heap_usable_size(&heap, ptr);
        // 可以使用额外的空间
        if (usable > requested_size) {
            // 利用额外的空间
        }
    }

**技巧2：批量分配**

.. code-block:: c

    // 不好的做法：频繁分配小对象
    for (int i = 0; i < 1000; i++) {
        void *ptr = sys_heap_alloc(&heap, 32);
        // 使用ptr
        sys_heap_free(&heap, ptr);
    }

    // 好的做法：批量分配
    void *batch = sys_heap_alloc(&heap, 1000 * 32);
    for (int i = 0; i < 1000; i++) {
        void *ptr = (char *)batch + i * 32;
        // 使用ptr
    }
    sys_heap_free(&heap, batch);

**技巧3：使用内存池**

.. code-block:: c

    // 对于固定大小的对象
    struct k_mem_pool my_pool;

    // 初始化内存池
    k_mem_pool_init(&my_pool, buffer, buffer_size, 
                   min_block_size, max_block_size, num_blocks);

    // 分配
    void *ptr = k_mem_pool_alloc(&my_pool, timeout);

    // 释放
    k_mem_pool_free(&my_pool, ptr);

7. 总结
========

7.1 核心要点
------------

1. **每个块都有头部**：
   - 已使用块：4/8字节头部
   - 空闲块：4/8字节头部 + 4/8字节链表指针

2. **三种配置**：
   - 小堆模式：4字节头部，最大262136字节堆
   - 大堆模式：8字节头部，最大16383MB堆
   - 自适应模式：根据堆大小自动选择

3. **用户可用内存**：
   - 小堆：块大小 - 4字节
   - 大堆：块大小 - 8字节

4. **头部开销**：
   - 块越小，开销百分比越大
   - 块越大，开销百分比越小

7.2 关键优势
------------

1. **双向遍历**：可以快速找到邻居
2. **溢出检测**：通过邻居一致性检测
3. **空间优化**：空闲块的链表指针在分配时给用户使用
4. **灵活性**：支持多种堆大小配置

7.3 实用建议
------------

1. 根据应用特点选择合适的堆模式
2. 了解实际可用内存大小
3. 对于固定大小的对象，考虑使用内存池
4. 增大块大小可以降低头部开销百分比

通过深入理解内存块头部结构，开发者可以更好地利用Zephyr的堆内存管理系统，优化内存使用，避免常见的内存问题。
