.. _zephyr-heap-bucket-algorithm-detailed:

Zephyr 堆桶机制与分配算法详解
################################

.. contents::
    :local:
    :depth: 3

1. 桶机制直观理解
==================

1.1 核心概念类比
----------------

**图书馆书架类比**：

想象一个图书馆，书籍（内存块）按照大小分类存放在不同的书架（桶）上：

- **书架0**：存放1-2页的小册子
- **书架1**：存放3-4页的小册子  
- **书架2**：存放5-8页的小册子
- **书架3**：存放9-16页的小册子
- **书架4**：存放17-32页的小册子
- **...**

当你需要一本书时，你不会从最大的书架开始找，而是从**刚好能装下**你所需页数的书架开始找。

1.2 为什么需要桶？
------------------

**问题**：如果所有空闲块都放在一个链表中，分配时需要遍历整个链表找到合适的块。

**解决方案**：将空闲块按大小分类，每个桶管理特定大小范围的块。

**优势**：

1. **快速定位**：直接跳到可能包含合适块的桶
2. **减少搜索**：只需搜索少数几个桶
3. **性能保证**：搜索次数有上限

1.3 桶的大小分类
------------------

Zephyr 使用**幂次大小**的桶，每个桶管理 2^n 大小范围的块：

.. code-block:: c

    // 桶索引计算
    static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
    {
        unsigned int usable_sz = sz - min_chunk_size(h) + 1;
        return 31 - __builtin_clz(usable_sz);
    }

**具体例子**（假设最小块大小为2个单位）：

+--------+------------------+------------------+------------------+
| 桶编号 | 大小范围(单位)   | 大小范围(字节)    | 说明             |
+========+==================+==================+==================+
| 0      | 2-3              | 16-24             | 最小块           |
+--------+------------------+------------------+------------------+
| 1      | 4-7              | 32-56             | 小块            |
+--------+------------------+------------------+------------------+
| 2      | 8-15             | 64-120            | 中小块          |
+--------+------------------+------------------+------------------+
| 3      | 16-31            | 128-248           | 中块            |
+--------+------------------+------------------+------------------+
| 4      | 32-63            | 256-504           | 中大块          |
+--------+------------------+------------------+------------------+
| 5      | 64-127           | 512-1016          | 大块            |
+--------+------------------+------------------+------------------+
| 6      | 128-255          | 1024-2040         | 超大块          |
+--------+------------------+------------------+------------------+
| ...    | ...              | ...               | ...             |
+--------+------------------+------------------+------------------+

**关键点**：

- 每个桶的大小范围是前一个桶的两倍
- 桶0的范围：2-3个单位（16-24字节）
- 桶1的范围：4-7个单位（32-56字节）
- 桶2的范围：8-15个单位（64-120字节）
- ...

1.4 桶的数据结构
------------------

**桶结构定义**：

.. code-block:: c

    struct z_heap_bucket {
        chunkid_t next;  // 指向桶中第一个空闲块
    };

**堆结构中的桶数组**：

.. code-block:: c

    struct z_heap {
        chunkid_t chunk0_hdr[2];
        chunkid_t end_chunk;
        uint32_t avail_buckets;  // 位图：哪些桶有可用块
        struct z_heap_bucket buckets[0];  // 灵活数组成员
    };

**avail_buckets 位图**：

- 第0位：桶0是否有可用块
- 第1位：桶1是否有可用块
- 第2位：桶2是否有可用块
- ...

**位图优势**：

- 快速判断哪些桶为空
- 使用位操作快速查找下一个非空桶
- O(1)时间复杂度

1.5 桶的内存布局图示
----------------------

```
堆内存布局：

+------------------+
| 堆控制结构       |  <-- 包含桶数组
| +--------------+ |
| | z_heap       | |
| | buckets[]    |  <-- 桶0, 桶1, 桶2, ...
| +--------------+ |
+------------------+
| 块0 (已使用)    |
+------------------+
| 块1 (空闲)      |  <-- 在桶2中
+------------------+
| 块2 (已使用)    |
+------------------+
| 块3 (空闲)      |  <-- 在桶3中
+------------------+
| 块4 (空闲)      |  <-- 在桶3中
+------------------+
| ...             |
+------------------+

桶的链表结构：

桶0: NULL (空)
桶1: NULL (空)
桶2: 块1 <-> 块1 (循环链表，只有一个元素)
桶3: 块3 <-> 块4 <-> 块3 (循环链表，两个元素)
桶4: NULL (空)
...
```

**循环链表特点**：

- 每个桶维护一个循环链表
- 链表中的所有块都是空闲的
- 链表中的块大小都在该桶的范围内
- 循环链表便于插入和删除

2. 分配算法详解
================

2.1 分配请求示例
----------------

让我们用一个具体的例子来说明分配过程：

**场景**：用户请求分配 100 字节的内存

**步骤1：计算需要的块大小**

.. code-block:: c

    // 假设是小堆，头部4字节，单位8字节
    bytes_to_chunksz(h, 100) = chunksz(4 + 100) / 8
                            = chunksz(104) / 8
                            = 13 / 8
                            = 2 (向上取整)
    
    // 实际需要：2个单位 = 16字节头部 + 100字节数据
    // 但由于对齐，实际分配可能更多

**步骤2：确定目标桶**

.. code-block:: c

    // 假设最小块大小为2个单位
    usable_sz = 2 - 2 + 1 = 1
    bucket_idx = 31 - __builtin_clz(1) = 31 - 31 = 0

    // 目标桶：桶0

**步骤3：执行分配算法**

2.2 两阶段分配算法
------------------

**阶段1：最小桶采样（智能搜索）**

.. code-block:: c

    // [heap.c:232-244]
    if (b->next != 0U) {
        chunkid_t first = b->next;
        int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;  // 默认为3
        do {
            chunkid_t c = b->next;
            if (chunk_size(h, c) >= sz) {
                free_list_remove_bidx(h, c, bi);
                return c;
            }
            b->next = next_free_chunk(h, c);
            CHECK(b->next != 0);
        } while (--i && b->next != first);
    }

**直观理解**：

想象你在桶0的书架上找一本至少100页的书：

1. 看第一本书：只有50页，不够
2. 看第二本书：只有60页，不够
3. 看第三本书：有120页，够了！拿走这本书

**为什么只检查3本？**

- **统计优化**：如果桶中的块大小分布均匀，检查3本有87.5%的概率找到合适的
- **性能保证**：即使找不到，也只花费固定时间
- **可配置**：可以通过CONFIG_SYS_HEAP_ALLOC_LOOPS调整

**阶段2：保证适配桶（保底策略）**

.. code-block:: c

    // [heap.c:249-258]
    uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);

    if (bmask != 0U) {
        int minbucket = __builtin_ctz(bmask);
        chunkid_t c = h->buckets[minbucket].next;

        free_list_remove_bidx(h, c, minbucket);
        CHECK(chunk_size(h, c) >= sz);
        return c;
    }

**直观理解**：

如果在桶0中没找到合适的书，就去下一个肯定有足够大书的书架：

1. 检查桶1：空，跳过
2. 检查桶2：有书，拿走第一本（肯定够大）

**位图操作详解**：

.. code-block:: c

    // 假设目标桶是桶0
    bi = 0
    BIT_MASK(bi + 1) = BIT_MASK(1) = 0b1
    
    // avail_buckets = 0b110100 (桶0,2,3有可用块)
    avail_buckets & ~BIT_MASK(1) = 0b110100 & ~0b1
                               = 0b110100 & 0b111110
                               = 0b110100
    
    // 找到第一个非零位
    __builtin_ctz(0b110100) = 2  // 桶2
    
    // 从桶2取块
```

2.3 完整分配流程图示
--------------------

```
用户请求：分配100字节

    ↓
[步骤1] 计算块大小
    bytes_to_chunksz(h, 100) = 13个单位
    
    ↓
[步骤2] 确定目标桶
    bucket_idx(13) = 桶3 (管理16-31个单位的块)
    
    ↓
[阶段1] 最小桶采样
    检查桶3的前3个块：
    ├─ 块A：15个单位 (太小)
    ├─ 块B：18个单位 (合适！) ← 找到了
    └─ (停止搜索)
    
    ↓
[步骤3] 块分割
    原始块B：18个单位
    需要的块：13个单位
    剩余的块：5个单位
    
    分割后：
    ├─ 块B1：13个单位 (分配给用户)
    └─ 块B2：5个单位 (返回到桶2)
    
    ↓
[步骤4] 返回内存
    返回块B1的地址给用户
```

2.4 分配失败的情况
------------------

**情况1：堆内存不足**

```
用户请求：分配10000字节

    ↓
[步骤1] 计算块大小
    bytes_to_chunksz(h, 10000) = 1251个单位
    
    ↓
[步骤2] 确定目标桶
    bucket_idx(1251) = 桶10
    
    ↓
[阶段1] 最小桶采样
    检查桶10：空
    
    ↓
[阶段2] 保证适配桶
    检查桶10及以上：全部为空
    
    ↓
[结果] 分配失败，返回NULL
```

**情况2：碎片化**

```
堆状态：
- 总空闲内存：5000字节
- 最大连续空闲块：1000字节

用户请求：分配2000字节

    ↓
[步骤1] 计算块大小
    bytes_to_chunksz(h, 2000) = 251个单位
    
    ↓
[步骤2] 确定目标桶
    bucket_idx(251) = 桶8
    
    ↓
[阶段1] 最小桶采样
    检查桶8：空
    
    ↓
[阶段2] 保证适配桶
    检查桶8及以上：全部为空
    
    ↓
[结果] 分配失败，返回NULL
    (虽然有5000字节空闲，但没有足够大的连续块)
```

3. 块分割与合并详解
====================

3.1 块分割过程
----------------

**场景**：从18个单位的块中分配13个单位

**分割前**：

```
+------------------+
| 块B (18个单位)  |  ← 空闲块
+------------------+
```

**分割操作**：

.. code-block:: c

    // [heap.c:109-122]
    static void split_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
    {
        chunksz_t sz0 = chunk_size(h, lc);      // 18
        chunksz_t lsz = rc - lc;                // 13
        chunksz_t rsz = sz0 - lsz;              // 5

        set_chunk_size(h, lc, lsz);            // 左块设为13
        set_chunk_size(h, rc, rsz);            // 右块设为5
        set_left_chunk_size(h, rc, lsz);        // 右块的左邻居设为13
        set_left_chunk_size(h, right_chunk(h, rc), rsz);  // 右邻居的左邻居设为5
    }

**分割后**：

```
+------------------+---------+
| 块B1 (13个单位) | 块B2 (5个单位) |
+------------------+---------+
     ↑                    ↑
  分配给用户          返回到桶2
```

**关键点**：

- 左块（B1）分配给用户
- 右块（B2）立即返回到空闲链表
- 邻居关系正确更新

3.2 块合并过程
----------------

**场景**：释放一个块，与相邻的空闲块合并

**释放前**：

```
+------------------+---------+------------------+
| 块A (已使用)     | 块B (空闲)      | 块C (空闲)      |
+------------------+---------+------------------+
```

**释放块A**：

.. code-block:: c

    // [heap.c:133-149]
    static void free_chunk(struct z_heap *h, chunkid_t c)
    {
        // 1. 检查右侧邻居
        if (!chunk_used(h, right_chunk(h, c))) {
            // 右侧是空闲块，合并
            free_list_remove(h, right_chunk(h, c));
            merge_chunks(h, c, right_chunk(h, c));
        }

        // 2. 检查左侧邻居
        if (!chunk_used(h, left_chunk(h, c))) {
            // 左侧是空闲块，合并
            free_list_remove(h, left_chunk(h, c));
            merge_chunks(h, left_chunk(h, c), c);
            c = left_chunk(h, c);
        }

        // 3. 添加到空闲链表
        free_list_add(h, c);
    }

**步骤1：检查右侧邻居**

```
+------------------+---------+------------------+
| 块A (空闲)      | 块B (空闲)      | 块C (空闲)      |
+------------------+---------+------------------+
     ↑
  正在释放
```

- 右侧邻居（块B）是空闲的
- 从桶中移除块B
- 合并块A和块B

**步骤2：检查左侧邻居**

```
+------------------+---------+------------------+
| 块D (空闲)      | 块AB (空闲)     | 块C (空闲)      |
+------------------+---------+------------------+
                   ↑
              合并后的块
```

- 左侧邻居（块D）是空闲的
- 从桶中移除块D
- 合并块D和块AB

**步骤3：添加到空闲链表**

```
+----------------------------------------+
| 块DAB (空闲)                        | 块C (空闲)      |
+----------------------------------------+------------------+
     ↑
  添加到桶中
```

- 将合并后的块添加到适当的桶中
- 更新桶的位图

3.3 合并算法详解
------------------

**合并操作**：

.. code-block:: c

    // [heap.c:125-131]
    static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
    {
        chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);

        set_chunk_size(h, lc, newsz);
        set_left_chunk_size(h, right_chunk(h, rc), newsz);
    }

**合并前**：

```
+------------------+---------+
| 块A (13个单位) | 块B (5个单位)  |
+------------------+---------+
```

**合并后**：

```
+------------------------+
| 块AB (18个单位)       |
+------------------------+
```

**关键点**：

- 只更新左块的大小
- 更新右邻居的左邻居指针
- 右块被"吸收"，不再独立存在

4. 实际应用场景分析
==================

4.1 场景1：频繁小分配
--------------------

**应用**：网络数据包处理

**特点**：

- 大量小分配（64-256字节）
- 频繁分配和释放
- 对延迟敏感

**桶的使用模式**：

```
分配请求分布：
- 64字节：40%  → 桶2
- 128字节：30% → 桶3
- 256字节：20% → 桶4
- 512字节：10% → 桶5

桶的使用情况：
- 桶2：最活跃
- 桶3：活跃
- 桶4：中等活跃
- 桶5：较少活跃
```

**优化建议**：

1. 使用内存池管理固定大小的数据包
2. 增加 CONFIG_SYS_HEAP_ALLOC_LOOPS 值
3. 监控碎片情况

4.2 场景2：大块分配
--------------------

**应用**：图像处理缓冲区

**特点**：

- 少量大分配（10KB-1MB）
- 分配后长期使用
- 对碎片敏感

**桶的使用模式**：

```
分配请求分布：
- 10KB：50%  → 桶10
- 100KB：30% → 桶13
- 1MB：20%  → 桶16

桶的使用情况：
- 桶10：活跃
- 桶13：中等活跃
- 桶16：较少活跃
```

**优化建议**：

1. 使用大堆模式（CONFIG_SYS_HEAP_BIG_ONLY）
2. 预分配大块内存
3. 避免频繁的小分配

4.3 场景3：混合分配
--------------------

**应用**：通用嵌入式应用

**特点**：

- 混合大小分配
- 不可预测的分配模式
- 需要平衡性能和内存使用

**桶的使用模式**：

```
分配请求分布：
- 小分配（<256字节）：60%
- 中分配（256B-4KB）：30%
- 大分配（>4KB）：10%

桶的使用情况：
- 桶0-4：最活跃
- 桶5-8：活跃
- 桶9+：较少活跃
```

**优化建议**：

1. 使用自适应模式（CONFIG_SYS_HEAP_AUTO）
2. 启用运行时统计监控
3. 定期检查堆健康状态

5. 性能优化技巧
================

5.1 调整分配循环次数
----------------------

**CONFIG_SYS_HEAP_ALLOC_LOOPS**：

- **默认值3**：87.5%成功率，常量时间
- **值5**：96.875%成功率，稍慢
- **值1**：50%成功率，最快

**选择建议**：

.. code-block:: kconfig

    # 高性能场景（如中断处理）
    CONFIG_SYS_HEAP_ALLOC_LOOPS=1

    # 平衡场景（默认）
    CONFIG_SYS_HEAP_ALLOC_LOOPS=3

    # 高成功率场景（如用户空间）
    CONFIG_SYS_HEAP_ALLOC_LOOPS=5

5.2 选择合适的堆模式
----------------------

**小堆模式**（CONFIG_SYS_HEAP_SMALL_ONLY）：

- 最大堆：262136字节
- 头部：4字节
- 适用：小内存设备

**大堆模式**（CONFIG_SYS_HEAP_BIG_ONLY）：

- 最大堆：16383MB
- 头部：8字节
- 适用：大内存设备

**自适应模式**（CONFIG_SYS_HEAP_AUTO）：

- 自动选择
- 最优内存效率
- 适用：不确定堆大小的场景

5.3 监控桶的使用情况
----------------------

**使用堆信息打印**：

.. code-block:: c

    #ifdef CONFIG_SYS_HEAP_INFO
    void monitor_buckets(struct sys_heap *heap)
    {
        sys_heap_print_info(heap, false);
        
        // 分析输出
        // - 哪些桶最活跃
        // - 哪些桶经常为空
        // - 碎片化程度
    }
    #endif

**输出示例**：

```
Heap at 0x20000000 contains 1024 units in 10 buckets

  bucket#    min units        total      largest      largest
             threshold       chunks      (units)      (bytes)
  -----------------------------------------------------------
       0            1           45           16          128
       1            3           30           32          256
       2            7           20           64          512
       3           15           10          128         1024
       4           31            5          256         2048
       5           63            3          512         4096
       6          127            2         1024         8192
       7          255            1         2048        16384
       8          511            0            0            0
       9         1023            0            0            0

分析：
- 桶0-3最活跃：小分配较多
- 桶8-9为空：很少有大块分配
- 碎片化程度：中等
```

6. 常见问题诊断
================

6.1 问题：分配成功率低
--------------------

**症状**：

- 频繁的分配失败
- 有足够空闲内存但无法分配

**诊断步骤**：

1. 检查碎片化程度
2. 检查桶的使用情况
3. 检查最大连续空闲块

**解决方案**：

1. 增加 CONFIG_SYS_HEAP_ALLOC_LOOPS
2. 优化分配模式
3. 使用内存池

6.2 问题：特定桶总是为空
------------------------

**症状**：

- 某些桶永远为空
- 其他桶过度使用

**诊断步骤**：

1. 分析分配模式
2. 检查是否有特定大小的分配需求

**解决方案**：

1. 调整分配策略
2. 使用内存池管理特定大小
3. 重新设计数据结构

6.3 问题：性能下降
--------------------

**症状**：

- 分配速度变慢
- 中断延迟增加

**诊断步骤**：

1. 检查 CONFIG_SYS_HEAP_ALLOC_LOOPS 值
2. 检查碎片化程度
3. 检查堆大小是否合适

**解决方案**：

1. 减少 CONFIG_SYS_HEAP_ALLOC_LOOPS
2. 优化内存使用
3. 增加堆大小

7. 总结
========

7.1 核心要点
------------

1. **桶机制**：
   - 按大小分类管理空闲块
   - 使用幂次大小范围
   - 位图快速查找

2. **分配算法**：
   - 两阶段策略
   - 最小桶采样（智能搜索）
   - 保证适配桶（保底策略）

3. **块管理**：
   - 即时合并空闲块
   - 按需分割大块
   - 最小化碎片

7.2 关键优势
------------

1. **性能保证**：常量时间复杂度
2. **空间效率**：最小化内存开销
3. **碎片抗性**：智能分配和合并
4. **可配置性**：丰富的配置选项

7.3 最佳实践
------------

1. 根据应用特点选择合适的配置
2. 监控堆的使用情况
3. 定期检查堆的健康状态
4. 使用内存池管理固定大小的对象

通过深入理解桶机制和分配算法，开发者可以更好地利用Zephyr的堆内存管理系统，开发出高效、可靠的嵌入式应用。
