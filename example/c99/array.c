// 数组初始化的时候可以指定索引，而且可以给特定范围的数组赋值。
// 比如
int array[] = { [0 ... 9] = 1, [10 ... 20] = 2, [30 ... 40] = 3};
// 等价于    int array[] = { 1, 1, 1, 1, ..... 2, 2, 2 ...... 3, 3, 3};

#include<stdio.h>

int  main()
{
    int i = 0;
    int arr[] = {[1] = 5, [5] = 10, [2] = 20};
    int arr2[] = {[0 ... 9] = 10, [10 ... 19] = 20, [20 ... 29] = 30};
    for (i = 0; i < 6; i++)
        printf("arr[%d] = %d ,", i, arr[i]);
    printf("\n");
    for (i = 0; i < 30; i++)
        printf("arr2[%d] = %d ,", i, arr2[i]);
    return 0;

// s[i] 是 *(s + i) 的语法糖，所以等价于 i[s]。
    char s[] = "vonzhou";
    printf("%c\n", 2[s]);   
 
    return 0;

}
//变长数组

/*严格说来，变长数组的实现在c++中并不是一件麻烦的事情。Stl中的vector本身就是一个变长数组，
并且有自动管理内存的能力。但是在c中，实现变长数组就稍显麻烦。用C实现，必然需要一个结构，结
构当中应当有一个指针，指针分配一段内存空间，空间大小根据需要而定，而且必须有另外一个字段记
录究竟开辟了多大多长的空间。
大致描述如下：*/


struct MutableLenArray
{
  int count;
  char* p;
};
P = new char[count];

// 没什么问题，但是C语言的使用者有个最大的自豪就在于对于效率、空间使用的掌控。他们会有这样的疑问，
// 如果count=0，那么p就没必要了，白白占了4（64位系统为8）个字节的空间，简直浪费。
// 那有没有更好的方式能实现上面的需求，又保证空间合理呢？答案是有的，用0长度


struct MutableLenArray 
{ 
    int count; 
    char p[0]; 
};
// 和上面的结构使用方法一致，但是我们可以用sizeof尝试读取其大小，发现竟然只有count
// 字段的长度4字节，p没有被分配空间。完美！